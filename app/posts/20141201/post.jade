include ../escape.jade

h1 Akka (notes, part 1)
div.panel.panel-default
  div.panel-heading 2014-12-01 [Scala, Akka]
  div.panel-body
    section
      header
        h4 Akka traits
      section
        img(src="img/reactive-traits.svg" alt="Akka traits" style="max-width: 40%")
        div Akka has 4 main traits. Those are:
          ul
            li Responsive - the system responds very fast.
            li Resilient - the system stays responsive in the face of failure.
            li Elastic - the system stays responsive under varying workload. You can easily add/remove nodes (machines) to/from system.  
            li Message Driven - object talks through messages. Objects are loosely coupled. There is a big diffrence between event and message - every message has recipient address, but events don't have to have it.
          div Please see <a href="http://www.reactivemanifesto.org/">Reactive Manifesto</a> for more information.
    section
      header
        h4 Concurrency vs parallelism
      section
        ul
          li Definition 1
          ul
            li <strong>Concurrency</strong> is when two tasks can start, run, and complete in overlapping time periods. It doesn't necessarily mean they'll ever both be running at the same instant. Eg. multitasking on a single-core machine.
            li <strong>Parallelism</strong> is when tasks literally run at the same time, eg. on a multicore processor.
          li Definition 2
          ul
            li <strong>Concurrency</strong> A condition that exists when at least two threads are making progress. A more generalized form of parallelism that can include time-slicing as a form of virtual parallelism.
            li <strong>Parallelism</strong> A condition that arises when at least two threads are executing simultaneously.
        div Ref: <a href="http://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference">http://stackoverflow.com/</a>.
        div Example
          ul
            li <strong>Concurrency</strong> - two queues, one coffee machine
            li <strong>Parallelism</strong> - two queues, two coffee machines
          img(src="img/20141201/con_and_par.jpg" alt="Concurrency vs Parallelism")
          div Source: <a href="http://joearms.github.io/2013/04/05/concurrent-and-parallel-programming.html">http://joearms.github.io/</a>
    section
      header
        h4 Actor, ActorRef
      section
        div
          img(src="img/actor-ref.png" alt="Actor with Mailbox" style="max-width: 40%")
          ul
            li Each actor has dispatcher and mailbox.
            li If we send message to actor, it will add message to its mailbox and it will return <strong>immediately</strong> - this is not blocking operation.
            li If we create actor, <code>actorOf</code> will return <strong>immediately</strong> <code>ActorRef</code>. It does not wait to create an instance. If we send messages to actor that is "not started", messages will be added to mailbox and will be processed when actor is inicialized - we will not lose any message.
            li <strong>Dispatcher</strong> assigns (schedules) thread to process the message.
            li Many actors have the same dispatcher - it is some kind of thread pool.
            li One message is passed to the actor
            li Only <strong>one</strong> thread can be in <strong>receive</strong> block ("single-threaded illusion").
            li Actors could have mutable state (but rember not to share mutable state!).
            li Messages must be immutable.
    section
      header
        h4 How to handle "unhandled" messages
      section If in receive block we do not handle some message, this message will be dropped (and maybe logged). We can use <code>unhandled</code> method to do something with messages not handled in receive block.
        pre
          code.scala override def unhandled(message: Any): Unit = ???
    section
      header
        h4 Top-Level Actor
      section If you create top-level actors, use factory methods - it will simplify testing. Always give name to your top-level actors.
        pre
          code.scala.
            val topLevelActor = createTopLevelActor()
            def createTopLevelActor(): ActorRef = system.actorOf(TopLevel.props, "top-level")
    section
      header
        h4 Message protocol
      section
        ul
          li Defince your message protocol in the companion object of the actor.
          li If you use message protocol from other actor, use actor name as prefix to this message - this will make code more readable.
          pre
            code.scala
              +escape()
                include code/MessageProtocol.scala
    section
      header
        h4 Actor DSL
      section To create anonymous actoes we can use <a href="http://doc.akka.io/docs/akka/2.3.0-RC1/scala/actordsl.html">Actor DSL</a>. Here, <code>actor</code> takes the role of either <code>system.actorOf</code> or <code>context.actorOf</code>. It takes an implicit <code>ActorRefFactory</code> and creates the new Actor.
        pre
          code.scala
            +escape()
              include code/ActorDSL.scala
    section
      header
        h4 Best practices
      section
        ul
          li Always create <code>Props</code> factory - the best place for that is in companion object (see: <a href="http://doc.akka.io/docs/akka/snapshot/scala/actors.html">Actors &mdash; Akka Documentation</a>).
          li Put Companion Object before you class.
          li Use <code>sender()</code> <strong>with</strong> parentheses. It is function, not val and you have to rember about it. It can be very tricky when sender() will be execute in other thread - in example in <code>Future</code>. Example:
            pre
              code.scala
                +escape()
                  include code/SenderInFuture.scala